#!/usr/bin/env python3

# The MIT License (MIT)
#
# Copyright (c) 2018 École Polytechnique Fédérale de Lausanne (EPFL)
# Author: Jagdish P. Achara
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import re
import pandas as pd
import matplotlib.pyplot as plt
from collections import defaultdict
import os
import signal
import sys


def GA_parse(log_file):

    float_pattern = \
        r'[+-]? *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?'
    data = defaultdict(lambda: [])
    patterns = {
        'tracking': re.compile(r'\(Smoothened\) PCC Request: ({})'
                               .format(float_pattern)),
        'slack': re.compile(r'P = ({})'
                            .format(float_pattern)),
        'follower': re.compile(r'P: ({})'
                               .format(float_pattern))
    }
    for line in log_file:
        if line.startswith('Tracking mode'):
            match = patterns['tracking'].search(line)
            value = float(match.group(1))
            data['tracking'].append(value)
        elif line.startswith('Slack Bus Power'):
            match = patterns['slack'].search(line)
            value = float(match.group(1))
            data['slack'].append(value)
        elif line.startswith('Setpoint computation failed'):
            # when find a "Setpoint computation failed" remove last two entries of tracking and slack
            print('Setpoint computation failed found in GA.out')
            del data['tracking'][-1]
            del data['slack'][-1]

        elif line.startswith('Follower'):
            match = re.match('Follower: (\S+)', line)
            follower = match.group(1)
            for line in log_file:
                if not line.strip():
                    break
                if re.search('as estimated by SE', line):
                    match = patterns['follower'].search(line)
                    if not match:
                        continue
                    value = float(match.group(1))
                    data[follower].append(value)
                    break
                elif re.search('as measured by RA', line):
                    match = patterns['follower'].search(line)
                    if not match:
                        continue
                    value = float(match.group(1))
                    data[follower].append(value)
                    break

    data_lens = [len(data[follower]) for follower in data.keys()]
    min_len = min(data_lens)
    for follower in data.keys() :
        if len(data[follower]) > min_len :
            print ("GA_parse() : reducing size of column", follower, "("+str(len(data[follower]))+") to match minimum column length ("+str(min_len)+")")
            data[follower] = data[follower][:min_len]

    return pd.DataFrame.from_dict(data)


# From https://pymotw.com/2/argparse/ or
# https://stackoverflow.com/questions/8632354/python-argparse-custom-actions-with-additional-arguments-passed
class AbsPathAction(argparse.Action):
    """Action to convert `argparse` arguments to absolute paths.

    """
    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        if nargs is not None:
            raise ValueError("`nargs` not allowed")
        super(AbsPathAction, self).__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest,
                os.path.abspath(os.path.expanduser(values)))


def signal_handler(signal, frame):
        sys.exit(0)


def main():
    # Parse the arguments.
    parser = argparse.ArgumentParser(
        description="Plot various files in data and output directories generated by different software agents/models run by `runtestbed.py`."
    )
    parser.add_argument('GA',
                        help="Path to the GA's (Commelec) output log file",
                        action=AbsPathAction)
    parser.add_argument('grid_bus',
                        help="Path to the grid's bus log file",
                        action=AbsPathAction)
    parser.add_argument('grid_line',
                        help="Path to the grid's line log file",
                        action=AbsPathAction)
    parser.add_argument('--slack', type=int, default=0,
                        help="Index of the slack bus")
    parser.add_argument('--batteries', nargs='*', default=[],
                        metavar='battery',
                        help="Path to the batteries' log files")
    parser.add_argument('--ucpvs', nargs='*', default=[],
                        metavar='ucpv',
                        help="Path to the UCPVs' log files")
    args = parser.parse_args()

    # Parse the GA log file and plot.
    with open(args.GA, 'r') as GA_file:
        try:
            df = GA_parse(GA_file)
            df.plot(title="GA (commelec)")
        except Exception as e:
            print("Could not plot GA data: {}".format(e))

    kwargs = {'index_col': 0, 'parse_dates': True, 'header': 0}

    # Parse and plot the grid bus log file.
    try:
        df = pd.read_csv(args.grid_bus, **kwargs)
        df.loc[df['BusIndex'] != args.slack, ['P', 'Q']] *= -1
        df = df[df.BusIndex != 0]

        plt.figure()
        for index, group in df.groupby('BusIndex'):
            plt.plot(group['P'], label='bus #{:d}'.format(index))
        plt.title("Real power (P, in W)")
        plt.legend(loc='best')

        plt.figure()
        for index, group in df.groupby('BusIndex'):
            plt.plot(group['Q'], label='bus #{:d}'.format(index))
        plt.title("Reactive power (Q, in Var)")
        plt.legend(loc='best')

        plt.figure()
        for index, group in df.groupby('BusIndex'):
            plt.plot(group['Vm'], label='bus #{:d}'.format(index))
        plt.title("Voltage magnitude (Vm)")
        plt.legend(loc='best')

        plt.figure()
        for index, group in df.groupby('BusIndex'):
            plt.plot(group['Va'], label='bus #{:d}'.format(index))
        plt.title("Voltage angle (Va, in degrees)")
        plt.legend(loc='best')
    except Exception as e:
        print("Could not plot grid data: {}".format(e))

    # Parse and plot the grid line log file.
    try:
        df = pd.read_csv(args.grid_line, **kwargs)
        df = df[df['Line #'] != 0]

        plt.figure(5)
        for index, group in df.groupby('Line #'):
            plt.plot(group['LineCurrent'], label='Line #{:d}'.format(index))
        plt.title("Line current (I)")
        plt.legend(loc='best')
    except Exception as e:
        print("Could not plot grid data: {}".format(e))

    for idx, battery in enumerate(args.batteries, 1):
        try:
            df = pd.read_csv(battery, **kwargs)
            df[["P", "Q"]].plot(title="Battery {:d} (Power)".format(idx))
            df[["SoC"]].plot(title="Battery {:d} (SoC)".format(idx))
        except Exception as e:
            print("Could not plot {} data: {}".format(battery, e))

    for idx, pv in enumerate(args.ucpvs, 1):
        try:
            df = pd.read_csv(pv, **kwargs)
            df.plot(title="PV #{:d} (Power)".format(idx))
        except Exception as e:
            print("Could not plot {} data: {}".format(pv, e))

    print('Press Ctrl+C to exit - (If it does not work close manually one plot)')
    # use signal to close when ctrl+c is pressed (because plt.show is a blocking method)
    signal.signal(signal.SIGINT, signal_handler)

    plt.show()


if __name__ == '__main__':
    main()
